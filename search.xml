<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈递归</title>
    <url>/zh/posts/About-Recursion/</url>
    <content><![CDATA[<p>递归是指在编程中函数在函数体中调用自身的过程，体现的是分而治之的思想。</p>
<p>用一张图来说明：</p>
<img data-src="/zh/posts/About-Recursion/Recursion-Google.png" class="" title="不过这个递归好像会导致栈区溢出 😂">
<span id="more"></span>
<h2 id="从与循环的关系看递归"><a class="header-anchor" href="#从与循环的关系看递归">¶</a> 从与循环的关系看递归</h2>
<p>从这个角度看，递归可以分为两种。</p>
<ol>
<li><strong>可以直接改写成循环的</strong>，这里称为第一类递归。</li>
<li><strong>改写成循环的时候需要用到栈的</strong>，这里称为第二类递归。</li>
</ol>
<p>第一种情况的例子有用于求最大公约数的辗转相除算法，还有求斐波那契数列第 n 项的算法，二分查找等：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fibonacci(number - <span class="number">1</span>) + fibonacci(number - <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TailRecursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">return</span> fibonacci(<span class="number">0</span>, <span class="number">1</span>, number);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> next, <span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fibonacci(next, current + next, number--);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temporary</span> <span class="operator">=</span> current + next;</span><br><span class="line">            current = next;</span><br><span class="line">            next = temporary;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看到，这一类的递归和循环之间存在着比较直接的对应关系，改写成循环不需要借助任何辅助数据结构，并且改写成循环之后还有可能降低开销甚至时间复杂度。例如：求斐波那契数列第 n 项的算法的递归形式的时间复杂的是惊人的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.765ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2548.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(2159.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，尾递归形式的时间复杂度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，而对应的循环形式的时间复杂度也是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<p>第二种情况的例子有二叉树的遍历等：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这里以二叉树的中序遍历为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Item&gt; {</span><br><span class="line"></span><br><span class="line">    Item item;</span><br><span class="line">    Node&lt;Item&gt; left;</span><br><span class="line">    Node&lt;Item&gt; right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        Stack&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        Node&lt;Item&gt; node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.println(node.item);</span><br><span class="line">            node = node.right();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看到，这一类递归若要改写成循环需要借助栈的帮助，就此例而言时间复杂度没有变化，都为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<h2 id="如何区分这两种递归"><a class="header-anchor" href="#如何区分这两种递归">¶</a> 如何区分这两种递归</h2>
<h3 id="尾递归"><a class="header-anchor" href="#尾递归">¶</a> 尾递归</h3>
<p>在具体讨论如何区分这两种递归之前，我们先来了解一个已有的定义：<em>尾递归</em></p>
<p>在具体讨论尾递归之前，我们先来了解一下另一个已有的定义：<em>尾调用</em></p>
<p>尾调用是指：一个函数里的最后一个动作是返回一个函数调用的情形。例如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 f 中最后一个动作是返回对函数 g 的调用，这就称之为尾调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> g();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 h 最后一个动作不是返回对函数 g 的调用，而是返回对函数 g 的调用结果再加 1，这就不是尾调用了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">h</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> g() + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 i 可以改写成函数 f，但函数 i 不能算是严格意义上的尾调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> g = g();</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而尾递归就是尾调用的的特例，尾递归函数中最后一个动作是返回对该函数自身的调用。上文中，辗转相除算法的递归形式就是尾递归的例子。而尾递归属于第一类递归，即可以直接改写为循环，不需要栈的辅助。而很多现代的编译期甚至会直接对尾递归进行优化，消除调用过程中的栈帧，这样就再也不会 StackOverflow 啦。</p>
<h3 id="递归函数的执行过程"><a class="header-anchor" href="#递归函数的执行过程">¶</a> 递归函数的执行过程</h3>
<p>为了了解为什么递归会分成这两种以及为什么尾递归属于第一类递归，我们先来分析递归函数的执行过程。</p>
<p>对于任何递归函数，其执行流程都可以看成两部分：</p>
<ul>
<li>
<p>向下调用</p>
<p>向下调用是指：函数调用自身这个过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向下调用会向下加大树的深度，也就是会增加栈帧。</p>
</li>
<li>
<p>向上返回</p>
<p>向上返回是指：函数调用执行完毕，结束自身并向调用方放回的过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向上返回会向上减小树的深度，也就是会减少栈帧。</p>
</li>
</ul>
<p>以辗转相除算法的递归函数为例，其执行过程如下图所示：</p>
<img data-src="/zh/posts/About-Recursion/Recursion-Process.svg" class="" title="辗转相除算法的递归函数执行流程图示">
<p>再以二叉树的中序遍历递归函数为例，其递归调用过程如下：</p>
<img data-src="/zh/posts/About-Recursion/Inorder-Traverse.svg" class="" title="二叉树的中序遍历递归函数执行流程图示">
<h3 id="观察"><a class="header-anchor" href="#观察">¶</a> 观察</h3>
<p>首先，我们来看辗转相除算法的递归调用过程，可以发现其具备以下特征：</p>
<ol>
<li>递归调用过程单调，这里的单调是指该函数的执行过程是先连续的向下调用，紧接着连续的向上返回直至结束。</li>
<li>只在向下调用的过程中用到参数。</li>
</ol>
<p>然后，我们来看二叉树的中序遍历的递归调用过程：</p>
<ol>
<li>递归调用过程不单调，向下调用和向上返回交叉着进行。</li>
<li>在向下调用的过程中用到参数后并返回后，继续使用到了参数。</li>
</ol>
<p>基于以上观察，我们了解到区分递归函数的关键可能与以下因素有关。</p>
<ol>
<li>向上返回过程中是否用到参数。</li>
<li>递归调用过程是否单调。</li>
</ol>
<h3 id="思考"><a class="header-anchor" href="#思考">¶</a> 思考</h3>
<h4 id="递归调用过程不单调"><a class="header-anchor" href="#递归调用过程不单调">¶</a> 递归调用过程不单调</h4>
<p>我们先来思考最显而易见的情形，当递归函数的调用过程不单调时，就如上文中提到的二叉树的中序遍历，由于每一层的递归调用的参数都有可能在接下来的调用过程中被再次用到，所以必须要把每一层的调用信息（包括参数，局部变量等）都存入栈中，以备在后面的调用过程中再次使用，所以，当递归调用过程不单调的时候，栈是必须的，因此该类递归属于第二类递归，即在改写为循环时需要使用到栈。</p>
<h4 id="递归调用过程单调"><a class="header-anchor" href="#递归调用过程单调">¶</a> 递归调用过程单调</h4>
<p>既然递归调用过程不单调属于第二类递归，那么是不是递归调用过程单调就属于第一类递归了呢？答案比想象中的要复杂，请看下面的分析：</p>
<h5 id="尾递归-2"><a class="header-anchor" href="#尾递归-2">¶</a> 尾递归</h5>
<p>首先我们来看递归调用过程单调中最简单的情形 —— 尾递归：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，尾递归函数的调用过程不仅单调，而且在连续向上返回的过程中除了向上层传递结果并没有额外操作，所有运算在连续向下调用的过程中就已完成，基于这种特点，我们可以认为其和循环直接等价。所以尾递归属于第一类循环，即改写为循环时无需使用栈。</p>
<h5 id="用到常数"><a class="header-anchor" href="#用到常数">¶</a> 用到常数</h5>
<p>现在我们在尾递归的基础上增加一些操作，在不改变其调用过程的单调性的前提下，在连续向上返回的这个过程中加入额外的运算：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other) + CONSTANT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line"></span><br><span class="line">            sum += CONSTANT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either + sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，虽然现在的递归函数已经不像尾递归那么 “纯正”，但其仍然属于第一类递归。看来在向上返回的过程中加上和常数的操作并不能改变其性质。</p>
<h5 id="用到参数"><a class="header-anchor" href="#用到参数">¶</a> 用到参数</h5>
<p>既然加上和常数操作不能改变其性质，那么要是加上和变量的操作呢？递归函数里面的变量从哪里来呢？参数！嗯，所以我们现在来试试在不改变其调用过程的单调性的前提下，在向上返回的过程中加上对参数的操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other) + other;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            sum += other;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either + sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>什么？？？怎么还是可以在改写为循环的时候不用到栈？难道递归调用过程单调就能断定递归函数属于第一类递归吗？其实不然，请看下面的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历二叉树最作边的路径上的全部节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Item&gt; {</span><br><span class="line"></span><br><span class="line">    Item item;</span><br><span class="line">    Node&lt;Item&gt; left;</span><br><span class="line">    Node&lt;Item&gt; right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树先序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中先序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(root.item);</span><br><span class="line">            root = root.left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树后序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中后序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        Stack&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;Item&gt; node = root; node != <span class="literal">null</span>; node = node.left) {</span><br><span class="line">            stack.push(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            Node&lt;Item&gt; node = stack.pop();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，在这个例子中，递归函数的调用过程仍然单调，同样也实在连续向上返回的过程中用到了参数，但为什么这个例子中就要用到栈呢？仔细观察，我们可以发现，上一个例子中我们作的操作比较特殊，这个操作是对一个整数的加法，而对整数的加法是一个累计的操作，我们只关心这个累计而来的结果，而不关心他是从第一个累加到最后一个还是从最后一个累加到第一个，所以在改写为循环时，通过把这些本该在第一次循环完之后再做的累加操作直接放在第一次循环中执行，就可以在不影响结果的情况下消除栈的使用。而在这个例子中，对二叉树节点的遍历操作，遍历的顺序也是影响结果的因素之一，所以对于后序遍历，我们必需要用到栈。</p>
<p>说到这里，我们再来回顾一下刚才用到常数的例子，无论是对于常数的累加操作，还是遍历操作，顺序都不会对结果造成任何影响，所以我们可以在改写为循环是消除掉对栈的使用。</p>
<h3 id="结论"><a class="header-anchor" href="#结论">¶</a> 结论</h3>
<ul>
<li>
<p>递归调用过程不单调 -&gt; 改写为循环时需要用到栈（第二类递归）</p>
</li>
<li>
<p>递归调用过程单调</p>
<ul>
<li>
<p>向上返回过程中没有用到参数 -&gt; 改写为循环时不需要用到栈（第一类递归）</p>
</li>
<li>
<p>向上返回过程中用到了参数</p>
<ul>
<li>递归调用过程中参数的使用顺序对结果无影响 -&gt; 改写为循环时不需要用到栈（第一类递归）</li>
<li>递归调用过程中参数的使用顺序对结果有影响 -&gt; 改成为循环时需要用到栈（第二类递归）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于作者水平所限，并不能从数学的角度严格证明上面的结论。因此上面的结论只是基于作者自己的观察作出的总结，因此可能不够完备，甚至错误。</p>
<p>本文的目的在于尝试提供一种相对简单的判别方法用于在将一个递归函数真正改写为循环之前判断其需不需要栈的辅助。</p>
<p>如果你发现了文章中的问题，或者有更好的思路，记得在下方评论哦。😊</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/zh/posts/Hello-World/</url>
    <content><![CDATA[<p>这是我的个人博客。</p>
<p>主要分享对于技术学习和思考，但不局限于此。</p>
<p>坚持原创，不定时更新。</p>
<span id="more"></span>
<h2 id="代码"><a class="header-anchor" href="#代码">¶</a> 代码</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="公式"><a class="header-anchor" href="#公式">¶</a> 公式</h2>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.699ex" height="2.185ex" role="img" focusable="false" viewBox="0 -883.9 3845.1 965.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(1041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2097.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msup" transform="translate(2975.6,0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mn" transform="translate(466,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container></p>
<h2 id="图表"><a class="header-anchor" href="#图表">¶</a> 图表</h2>
<pre><code class="highlight mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;</code></pre>
<h2 id="图片"><a class="header-anchor" href="#图片">¶</a> 图片</h2>
<img data-src="/zh/posts/Hello-World/San-Francisco.png" class="" title="San Francisco">
<h2 id="笔记"><a class="header-anchor" href="#笔记">¶</a> 笔记</h2>
<div class="note default"><p>Hello World!</p>
</div>
<div class="note primary"><p>Hello World!</p>
</div>
<div class="note success"><p>Hello World!</p>
</div>
<div class="note info"><p>Hello World!</p>
</div>
<div class="note warning"><p>Hello World!</p>
</div>
<div class="note danger"><p>Hello World!</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何仅通过本地缓存就将数据库查询量级从 71.7 万/秒降至 1.4 万/秒</title>
    <url>/zh/posts/Locality-of-Reference-and-Cache/</url>
    <content><![CDATA[<blockquote>
<p>原标题：利用空间局部性原理大幅优化数据库查询量级</p>
</blockquote>
<h2 id="局部性原理"><a class="header-anchor" href="#局部性原理">¶</a> 局部性原理</h2>
<p>程序的局部性原理是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行期间所访问的存储空间也局限于某个内存区域。</p>
<p>局部性原理又可分为：</p>
<ul>
<li><strong>时间局部性</strong>：是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。比如在函数调用的时候，前不久才使用过的函数参数或局部变量容易再度被调取使用。</li>
<li><strong>空间局部性</strong>：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。空间局部性比较常见于循环中，比如在一个数组中，如果第 3 个元素在上一个循环中使用，则本次循环中极有可能会使用第 4 个元素。</li>
</ul>
<span id="more"></span>
<h2 id="缓存"><a class="header-anchor" href="#缓存">¶</a> 缓存</h2>
<p>正是由于程序的局部性，将热点数据放置到更快的存储设备上，那么将极大的提升程序的执行效率，这便是缓存。其本质是用空间换时间，牺牲数据的实时性，以近端暂存的历史数据代替远端最新的数据，从而减少访问内存、网络 IO 等高开销操作，以提升程序的性能表现。</p>
<h2 id="缓存友好性"><a class="header-anchor" href="#缓存友好性">¶</a> 缓存友好性</h2>
<p>由于缓存的有效性由程序的局部性来支持，因此衡量程序是否缓存友好，即衡量其局部性的强弱。</p>
<p>关于缓存友好性，有一个经典的案例：堆排序有着最强的理论性能一一最坏时间复杂度 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4001 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1752,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2535,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(3012,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，但在实际应用性能表现通常却不如最坏时间复杂度 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 的快速排序，便是由于堆排序的访存空间局部性太差，导致其缓存友好性很差，进而在现代计算机体系结构中吃了大亏。</p>
<p><strong>快速排序</strong></p>
<img data-src="/zh/posts/Locality-of-Reference-and-Cache/Quicksort-Animation.gif" class="" title="快速排序示例动画，来自维基百科">
<p>可以发现其分治算法的特性会使得其对内存的访问局限在一定的范围，从而具备了较好的空间局部性。</p>
<p><strong>堆排序</strong></p>
<img data-src="/zh/posts/Locality-of-Reference-and-Cache/Heapsort-Animation.gif" class="" title="快速排序示例动画，来自维基百科">
<p>可以发现其对于内存的访问模式相对 “跳跃”，这导致了较差的空间局部性。</p>
<h2 id="分布式系统中如何利用局部性原理"><a class="header-anchor" href="#分布式系统中如何利用局部性原理">¶</a> 分布式系统中如何利用局部性原理</h2>
<h3 id="分布式系统的存储层次结构"><a class="header-anchor" href="#分布式系统的存储层次结构">¶</a> 分布式系统的存储层次结构</h3>
<img data-src="/zh/posts/Locality-of-Reference-and-Cache/Memory-Hierarchy.svg" class="" title="分布式系统中的存储层次结构">
<h3 id="在分布式系统中利用时间局部性"><a class="header-anchor" href="#在分布式系统中利用时间局部性">¶</a> 在分布式系统中利用时间局部性</h3>
<p>在了解如何在分布式系统中利用时间局部性之前，我们先来了解在单机的计算机体系结构层面是如何利用时间局部性的。</p>
<p>以 Apple M1 为例，其搭载了堪称豪华的超大规模、多级片上缓存：</p>
<table>
    <tbody><tr>
        <th></th>
        <th>低功耗核心 (Icestorm)</th>
        <th>高性能核心 (Firestorm)</th>
    </tr>
    <tr>
        <th>L1 指令</th>
        <td>128 KB x 4</td>
        <td>192 KB x 4</td>
    </tr>
    <tr>
        <th>L1 数据</th>
        <td>64 KB x 4</td>
        <td>128 KB x 4</td>
    </tr>
    <tr>
        <th>L2</th>
        <td>4 MB（低功耗核心共享）</td>
        <td>12 MB（高性能核心共享）</td>
    </tr>
    <tr>
        <th>SLC</th>
        <td colspan="2" align="center">8MB（全片共享）</td>
    </tr>
</tbody></table>
<p>其具备以下特点：</p>
<ol>
<li><strong>代码指令和程序数据分离</strong>：在 L1 缓存中，由于代码指令和程序数据通常在体积层面差距较大，而 L1 缓存容量较小，如果不进行分离，那么可能导致绝大部分 L1 缓存被程序数据占据，导致代码指令的缓存命中率低下，从而影响性能。</li>
<li><strong>多级缓存</strong>：从 L1 到 L2 再到 SLC，速度依次下降，容量依次增大。数据的局部性越强，那么就越可能被更快的 L1、L2 命中。</li>
<li><strong>独占和共享相结合</strong>：L1 缓存为每个核心独占，L2 缓存在核心簇内共享，而 SLC 则在整个 SOC 层面共享（包括 CPU、GPU、NPU 等）。</li>
</ol>
<p>我们来看如何将上述的策略运用到分布式系统集群中：</p>
<ol>
<li><strong>代码指令和程序数据分离</strong> —— 配置数据缓存与用户数据缓存甚至不同场景或不同用途的缓存都尽量分离。</li>
<li><strong>多级缓存策略</strong> —— 单机缓存、分布式缓存等并用的多级缓存策略。</li>
<li><strong>独占和共享相结合</strong> —— 本地缓存单机独占、分布式缓存集群共享。</li>
</ol>
<p>通过上述缓存策略的合理运用，我们能够尽可能的挖掘程序中的时间局部性，同时能够平衡不同缓存在速度、容量、成本之间的差异。</p>
<h3 id="在分布式系统中利用空间局部性"><a class="header-anchor" href="#在分布式系统中利用空间局部性">¶</a> 在分布式系统中利用空间局部性</h3>
<p>在了解如何在分布式系统中利用空间局部性之前，我们先来了解在单机的计算机体系结构层面是如何利用空间局部性的。</p>
<p>众所周知，内存 (RAM) 的最小寻址单元是字节 (byte)，也就是说字节是内存中原子单元，不可再细分。这也就是为什么布尔 (boolean) 类型明明只包含一个比特 (bit) 的信息，但一般也必须要用一个字节在内存中存储。</p>
<p>那么 CPU 中的 L1、L2 等高速缓存也是以字节为原子单元吗？</p>
<p>是也不是：</p>
<ul>
<li><strong>是</strong>：由于高速缓存一般对指令集透明，其必须要和内存保持一致的按字节寻址的特性，因此对于缓存的访问而言，其原子单元和内存一致，为字节。</li>
<li><strong>不是</strong>：但对于缓存的加载而言，其原子单元却并不是和内存一致的字节，而是缓存行 (Cache Line)，以上面提到的 M1 处理器为例，其缓存行大小 (Cache Line Size) 为 128 字节。也就是说，如果出现缓存不命中，需要从内存中加载数据到缓存中时，即使我访问的只是内存中的一个字节，那么缓存也会把这个字节所在的缓存行，也就是 128 个字节的数据全部加载到缓存中。</li>
</ul>
<p>那么为什么缓存在加载的时候不只加载所需的数据，而是要加载整个缓存行？这不会造成浪费吗？</p>
<p>具体原因大致为以下几点：</p>
<ul>
<li>缓存行的设计可以充分利用现代 DRAM 的突发模式 (Burst mode) 特性，大幅提高访存吞吐量和减少延迟，这里不具体展开。</li>
<li>如果能提升系统的整体性能，一定程度的局部浪费是完全可以接受的。比如 CPU 中的分支预测特性也体现了类似的思路。</li>
<li>浪费的程度实际上取决于程序的空间局部性是否明显，局部性越明显，那么浪费就越小。</li>
<li>理论上缓存行的大小越大，那么对于局部性强的程序的性能提升也就越明显。当然，缓存行的大小还要受到其他各种物理因素的制约，并不能想多大就多大，也不是越大越好。</li>
</ul>
<p>可以看到，缓存行的设计目标很大程度上就是为了挖掘程序的空间局部性以提升性能。又或者说鼓励程序的空间局部性，空间局部性强的程序在这套机制下会得到性能的提升，而空间局部性差的程序在这套机制下会得到性能惩罚，正如前面提到的快速排序和堆排序。</p>
<p>因此，要想利用空间局部性的关键就在于：在加载缓存数据的时候，不仅要加载当前所需的数据，还要把 “相邻” 的一部分数据也一并加载进来，即：<strong>缓存的数据加载粒度 &gt; 缓存的数据查询粒度</strong>。</p>
<p>然而，当我们尝试将这种思路应用到分布式系统中时，会面临两大难题：</p>
<ul>
<li><strong>如何定义 “相邻”</strong>：内存的相邻很好定义，就是物理地址相邻，但是对于数据库中的数据而言，情况会复杂得多，甚至同一张表中的数据，在不同的使用场景下，其相邻的定义可能也不尽相同。</li>
<li><strong>如何确定缓存加载的最小数据单位</strong>：也就是类似 CPU 高速缓存的缓存行大小。这个值太小对空间局部性的利用程度有限，这个值太大会对缓存的加载开销和空间占用造成较大的压力。</li>
</ul>
<p>这两个问题没有一个通行的答案，而是需要根据自己的实际场景来权衡。下面，我将使用一个实际案例来为大家说明。</p>
<h2 id="实践案例"><a class="header-anchor" href="#实践案例">¶</a> 实践案例</h2>
<h3 id="背景与挑战"><a class="header-anchor" href="#背景与挑战">¶</a> 背景与挑战</h3>
<p>我所负责的一个面向消费者运营领域的无代码开发平台。其通过有向无环图来对消费者运营领域内的各种运营策略进行建模，来帮助运营直接实施各种体系化、精细化的运营措施。简称 “策略平台”。</p>
<p>策略平台除了利用有向无环图这一复杂模型以外，另一大特色便是其模型的有状态性。也就是说策略平台会记录每一个用户在每一个有向无环图的中所处的顶点等状态信息，这种有状态性进一步提升了模型的表达能力，因此能够支撑大量更加复杂的实际业务场景。</p>
<p>然而，天下没有免费的午餐，存储、写入、查询这些用户状态数据将会面临很多挑战，具体可分为以下几个方面：</p>
<ul>
<li><strong>需要存储的数据量巨大</strong>，预估数据量级将达 10 亿以上，后续会随平台使用情况、业务量级等因素持续增长。</li>
<li><strong>需要写入的数据量巨大</strong>，预计写入 TPS 将达 1 万以上，同样会随平台使用情况、业务量级等因素持续增长。</li>
<li><strong>需要查询的数据量更大</strong>，预计查询 QPS 将达 10 万以上，同样会随平台使用情况、业务量级等因素持续增长。</li>
</ul>
<h3 id="应对措施"><a class="header-anchor" href="#应对措施">¶</a> 应对措施</h3>
<p><strong>针对数据量大的问题</strong></p>
<ul>
<li>在数据库选型阶段选择了 Lindorm（阿里云改良版 HBase）以支撑海量的数据。同时利用其表级、行级 TTL (Time To Live) 机制，可以很方便的实现历史数据的自动清理。</li>
<li>同时，为了节省成本，选择了共享集群，其按照实际的存储、写入、查询用量来计费。但共享集群会存在 “吵闹邻居 (Noisy neighbour)” 的问题，会面临一些偶发的抖动，因此需要做一些容错措施。</li>
</ul>
<p><strong>针对写入数据量大的问题</strong></p>
<ul>
<li>Lindorm (HBase) 基于 LSM Tree 数据结构，其所有写入操作都是顺序写入，而无论是 SSD 还是 HDD，其顺序写入都是离散写入性能的数倍，因此可以提供显著的写入性能。</li>
<li>状态数据批量合并写入，对状态数据进行一定程度的合并处理再批量写入，以降低写入 TPS 并提升吞吐量。</li>
<li>状态数据裁剪，在写入前对状态数据进行过滤，仅保留有向无环图中被其他顶点依赖的顶点的状态数据，而非执行过程中涉及到的所有顶点的状态数据。经验证，此措施能大幅减少存储、写入、和查询的数据量。</li>
<li>另外，针对共享集群的偶发抖动，在数据库写入时采取了通过消息队列重试来进行容错，同时利用 Lindorm 所提供的时间戳多版本特性来解决重试导致的写入乱序而造成的数据不一致问题。</li>
</ul>
<p><strong>针对查询量级大这一最大挑战</strong></p>
<p>毫无疑间，查询请求量大这个问题才是最大的挑战。并且仅依靠常见的缓存策略，即仅挖掘时间局部性，对于该问题的帮助不大，原因如下：</p>
<ul>
<li>在一次请求处理过程中，反复访问同一个顶点的状态数据的情况有，但很少，因此可以预期的此缓存的命中率不会高。</li>
<li>在此基础上如果再引入多级缓存策略，无非就是将查询量级分摊一部分至 Redis 之类的存储，这将带来额外的成本、系统链路中的依赖增多导致进而导致 SLA 下降等问题。</li>
</ul>
<p>因此，我不得不另辟蹊径，从另外两个思路出发：</p>
<ol>
<li>在数据写入时，我们可以采取批量合并的策略，将多次单条数据的写入请求合并为一次批量的写入请求来降低 TPS 提高吞吐量。那么在查询的时候，与之对应的策略是什么？</li>
<li>请求通常是用户维度的，一次请求进来通常涉及多个有向无环图的执行，同时每个有向无环图执行时又涉及多个顶点。这里存在明显的放大效应，即：状态数据库的查询量级 = 请求量级 x 平均每个请求涉及的有向无环图数量 × 平均每个有向无环图涉及的顶点数量。</li>
</ol>
<blockquote>
<p>思路 1 如果走偏了会变成：单条数据的查询请求来了先阻塞住，等攒到了一定的数量或者达到一定的时间了再用一个批量查询请求到数据库。这样的确能够做到批量合并，但毫无疑问会确定性的增加请求延迟，并且一次能攒多少不好说，也就是代价是一定会付出的，但是效果不一定有保障。另外，这种方式攒的请求通常都属于不同的用户，在数据库中的物理分布会相对离散，将这样的请求合并到一起做批量查询对数据库查询性能到底是有益还是有害还真不好说… 至少索引的开销应该是节省不了太多，相比于查询一批相邻的数据来说。</p>
</blockquote>
<p>最终，两个思路殊途同归，都指向一点：<strong>缓存的数据加载粒度 &gt; 缓存的数据查询粒度</strong>。也就是我们前面所提到的 CPU 高速缓存中缓存行设计所体现的思路，以此来尝试挖掘状态数据查询请求的空间局部性。</p>
<p><strong>表的主键结构以及缓存加载策略</strong></p>
<p>由于 Lindorm 数据库中的状态表的主键（相当于 HBase 中的 Rowkey）的构成是：（用户 ID，有向无环图 ID，顶点 ID），即：(userld, graphld, vertexld)。同时 Lindrom 同 HBase 一样支持最左前缀匹配的范围查询。</p>
<p>要实现 “缓存的数据加载粒度 &gt; 缓存的数据查询粒度”，有两种选择：</p>
<ol>
<li><strong>缓存加载粒度：(userld, graphld)</strong>。查询某个用户在某个有向无环图中的某个顶点的状态数据，将会触发将这个用户在这个有向无环图中的所有顶点的状态数据都一并加载到缓存中。</li>
<li><strong>缓存加载粒度：(userld)</strong>。查询某个用户在某个有向无环图中的某个顶点的状态数据，将会触发将这个用户在所有有向无环图中的所有顶点的状态数据都一并加载到缓存中。</li>
</ol>
<p>当然，缓存的查询粒度取决于场景，必须保持完整的 (userld, graphld, vertexId) 不变。</p>
<p>几种缓存加载策略的对照如下：</p>
<table>
<thead>
<tr>
<th>缓存加载粒度</th>
<th>加载数据行数</th>
<th>加载数据量</th>
<th>加载延迟</th>
<th>空间局部性</th>
<th>内存压力</th>
</tr>
</thead>
<tbody>
<tr>
<td>(userld, graphld, vertexld)</td>
<td>一行</td>
<td>小</td>
<td>低</td>
<td>无</td>
<td>小</td>
</tr>
<tr>
<td>(userld, graphld)</td>
<td>相邻多行</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>(userld)</td>
<td>相邻多行</td>
<td>大</td>
<td>高</td>
<td>高</td>
<td>大</td>
</tr>
</tbody>
</table>
<h3 id="初探空间局部性"><a class="header-anchor" href="#初探空间局部性">¶</a> 初探空间局部性</h3>
<p>由于在开发阶段就已经意识到用户状态的查询将会是系统中最大的性能热点，因此在平台上线之初就直接将此缓存的加载粒度配置到了 (userld, graphld) 的粒度，以此来挖掘一定程度的空间局部性，同时又避免带来过大的浪费和内存压力。当然，我们仍然可以通过监控缓存的原始查询量来估计以 (userld, graphld, vertexld) 为缓存加载粒度时甚至无缓存时数据库会面临的查询量级。</p>
<p>(userld, graphld) 方案上线后，指标如下：</p>
<table>
<thead>
<tr>
<th>缓存加载粒度</th>
<th>缓存查询量级</th>
<th>缓存加载量级</th>
<th>平均缓存加载耗时</th>
<th>均摊缓存查询耗时 *</th>
</tr>
</thead>
<tbody>
<tr>
<td>(userld, graphld, vertexld)</td>
<td>6.8 万 / 秒</td>
<td>6.8 万 / 秒</td>
<td>1 毫秒 / 次</td>
<td>1 毫秒 / 次</td>
</tr>
<tr>
<td>(userld, graphld)</td>
<td>6.8 万 / 秒</td>
<td>1.6 万 / 秒</td>
<td>1.5 毫秒 / 次</td>
<td>0.35 毫秒 / 次</td>
</tr>
</tbody>
</table>
<p>均摊缓存查询耗时 *：指将总的缓存加载耗时均摊到总的缓存查询量级上。即：平均缓存加载耗时 x 缓存加载量级 ÷ 缓存查询量级</p>
<p>可以看到，通过挖掘空间局部性：</p>
<ul>
<li>缓存加载量级，即数据库的查询量级，下降到仅为原来的 23.5%。</li>
<li>但由于每次加载的数据量增多，单次加载耗时增加到原来的 150%，但绝对值仍然处于非常优秀的水平。</li>
<li>另外，如果我们将总的加载耗时均摊到总的查询量级上，即均摊分析。均摊查询耗时下降到仅为原来的 35%。也就是说，在查询用户状态数据这个场景上的整体开销下降了 65% 之多。</li>
</ul>
<h3 id="推向极限"><a class="header-anchor" href="#推向极限">¶</a> 推向极限</h3>
<p>(userld, graphld) 方案上线后，经过一段时间的观察，我们发现内存压力和数据量级比预期中的小很多，完全处于可接受的水平。</p>
<p>因此，我们直接将这个方案推向极致 —— 缓存加载粒度来到 (userId)！</p>
<table>
<thead>
<tr>
<th>缓存加载粒度</th>
<th>缓存查询量级</th>
<th>缓存加载量级</th>
<th>平均缓存加载耗时</th>
<th>均摊缓存查询耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>(userld, graphld, vertexld)</td>
<td>6.8 万 / 秒</td>
<td>6.8 万 / 秒</td>
<td>1 毫秒 / 次</td>
<td>1 毫秒 / 次</td>
</tr>
<tr>
<td>(userld, graphld)</td>
<td>6.8 万 / 秒</td>
<td>1.6 万 / 秒</td>
<td>1.5 毫秒 / 次</td>
<td>0.35 毫秒 / 次</td>
</tr>
<tr>
<td>(userld)</td>
<td>6.8 万 / 秒</td>
<td>0.28 万 / 秒</td>
<td>3.9 毫秒 / 次</td>
<td>0.16 毫秒 / 次</td>
</tr>
</tbody>
</table>
<p>可以看到，将空间局部性的挖掘做到极致以后：</p>
<ul>
<li>缓存加载量级，即数据库的查询量级，下降到仅相当于查询量级 4.12% 的水平！</li>
<li>由于每次加载的数据量更多，单次加载耗时增加到接近原来的 4 倍，但绝对值仍然处于可接受的水平。</li>
<li>均摊查询耗时下降到仅为原来的 16%。也就是说，在查询用户状态数据这个场景上的整体开销下降了 84% 之多！</li>
</ul>
<h3 id="长期表现"><a class="header-anchor" href="#长期表现">¶</a> 长期表现</h3>
<p>平台经过较长时间的发展以后，状态缓存的查询量级又上了好几层楼，同时得益于在写入侧所做的数据裁剪等优化，最新的指标如下：</p>
<table>
<thead>
<tr>
<th>时间节点</th>
<th>缓存加载粒度</th>
<th>缓存查询量级</th>
<th>缓存加载量级</th>
<th>平均缓存加载耗时</th>
<th>均摊缓存查询耗时 *</th>
</tr>
</thead>
<tbody>
<tr>
<td>上线</td>
<td>(userld)</td>
<td>6.8 万 / 秒</td>
<td>0.28 万 / 秒</td>
<td>3.9 毫秒 / 次</td>
<td>0.16 毫秒 / 次</td>
</tr>
<tr>
<td>现在</td>
<td>(userld)</td>
<td>71.7 万 / 秒</td>
<td>1.4 万 / 秒</td>
<td>1.17 毫秒 / 次</td>
<td>0.02 毫秒 / 次</td>
</tr>
</tbody>
</table>
<p>通过最新的数据我们可以观察到：</p>
<ul>
<li>缓存加载量级，即数据库的查询量级，仅相当于查询量级的 1.95%！</li>
<li>此缓存的命中率稳定维持在 97.95% 左右。</li>
<li>单次缓存加载耗时降至 1.17 毫秒 / 次！此指标下降主要得益于写入侧的数据裁剪等优化，导致数据库整体的数据量级下降，因此这里需要加载的数据量也有较大的下降，从而加载耗时也大幅减小。</li>
<li>均摊查询耗时下降到惊人的 0.02 毫秒 / 次。也就是说，在查询用户状态数据这个场景上的整体开销下降了 98% 之多！</li>
</ul>
<p>在查询量级大幅上涨后，配合写入侧的优化措施，(userld) 方案表现出了更大的潜力，而这都得益于其对空间局部性的充分挖掘。</p>
<h3 id="风险"><a class="header-anchor" href="#风险">¶</a> 风险</h3>
<p>看到这里，你肯定会担心，代价是什么？</p>
<ul>
<li>这么激进的缓存加载策略，会不会把内存打爆？</li>
<li>会不会存在某个用户 ID 下有海量的数据？</li>
<li>GC 压力如何？</li>
<li>内存要求会不会特别高？</li>
</ul>
<p>这些担忧都是非常有必要的，因此我们基于 Prometheus 自定义监控指标和内部的监控系统，对相关指标进行了详细且完备的监控：</p>
<ul>
<li>本地缓存使用数量、查询命中率、查询量级、加载量级、平均加载时长、加载失败率、驱逐量级等。</li>
<li>状态数据库表的批量写入大小和批量读取大小。用以监控单个用户名下数据量过大之类的风险。</li>
<li>单机的 JVM GC 表现，包括：每分钟 GC 频次、每分钟累计 GC 耗时、堆内存使用情况等。</li>
</ul>
<p>需要声明的是：</p>
<ul>
<li>状态缓存加载后仅 1 秒的有效期。</li>
<li>所有单机均为 4 核 CPU、8 GiB RAM 规格的 x86 容器。</li>
</ul>
<p>而通过上述的监控指标可以观察到：</p>
<ul>
<li>状态缓存的单机峰值利用率在 600 项左右，并不大，且距离 2048 的最大项数还有一定距离。</li>
<li>通过状态数据库表的批量查询监控观察到，批量查询的最大数据量在 12 条 / 批左右，且长期保持稳定，不存在任何尖刺。同时，从策略平台这个场景出发，也极不可能出现单用户名下数据量超多的情形。</li>
<li>单机的 GC 表现在 JDK 21 + G1 GC 的加持下，GC 频次在 2-5 次/分钟，GC 累计耗时在 40-130 毫秒/分钟（不是单次 GC 耗时），并且全是 Young GC。</li>
<li>单机 4 GiB 的堆内存，经过 Young GC 后能够下探到 20% 左右的水位。</li>
</ul>
<p>即各项指标都处于非常健康的水平。</p>
<h3 id="回顾"><a class="header-anchor" href="#回顾">¶</a> 回顾</h3>
<p>前文曾提到，要将能够挖掘空间局部性的缓存策略，即：缓存的数据加载粒度 &gt; 缓存的数据查询粒度，应用到分布式系统中时，会面临两大难题：</p>
<ol>
<li>如何定义 “相邻”？</li>
<li>如何确定缓存加载的数据粒度，即 “缓存行大小”？</li>
</ol>
<p>那么在上述的案例中，这两个难题是如何解决的？</p>
<ul>
<li><strong>如何定义 “相邻”</strong>：在这个案例中，无论是按照 (userld, graphld) 还是 (userld) 的粒度来进行缓存加载，其都是符合数据库主键 (Rowkey) 的最左前缀匹配原则的。这意味着这些数据在实际存储时，在物理层面，也都是相邻的，这样在查询时能够很好的利用数据库乃至底层硬件的特性，减少索引开销，利用顺序读取等特性，从而优化批量查询时的性能开销，做到 1 + 1 &lt; 2 的效果。</li>
<li><strong>缓存加载的数据粒度</strong>：不同于 CPU 中的缓存行，其面临晶体管数量等严格的物理限制。在分布式系统中，我们面临的限制相比之下通常宽松得多，例如：内存大小。因此在这个案例中，我们得以以 (userld, graphld) 甚至 (userld) 这样的不定长粒度来作为缓存加载的数据粒度，从而将空间局部性挖掘到极致，这在 CPU 这类面临严苛物理限制的场景将是难以想象的。</li>
</ul>
<p>当然，这个案例本身具有一定的特殊性，状态数据的分布总体而言是相对稀疏的，尤其对于裁剪后的状态数据。在更加普遍的场景中，我们还是建议对缓存加载数据量设置一个硬限制，比如：批量加载时最多加载 N 行数据。这样虽然对于空间局部性的挖掘不能到达极限，但能够很好的控制内存压力，能够适用于更加广泛的场景，例如：单用户名下的数据就超过内存承受极限的场景。也更加类似于 CPU 中的缓存行的做法。</p>
<p>另外，在缓存加载时，对于数据库中不存在的值，一定要设置空对象来占位，以防止缓存穿透。并且这种防穿透的效果，也能随着缓存加载粒度的扩大而被增强。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>性能工程</tag>
        <tag>计算机体系结构</tag>
        <tag>分布式系统</tag>
        <tag>实践经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos Made Simple 翻译及总结</title>
    <url>/zh/posts/Paxos-Made-Simple-Reading/</url>
    <content><![CDATA[<h2 id="Warm-up-预热"><a class="header-anchor" href="#Warm-up-预热">¶</a>Warm-up / 预热</h2>
<blockquote>
<p>The Paxos algorithm, when presented in plain English, is very simple.</p>
<p><strong>Leslie Lamport</strong> — Paxos Made Simple</p>
</blockquote>
<blockquote>
<p>The Fast Paxos algorithm, when presented in plain English, is still quite hard to understand for those like us — people who don’t have the brain of Leslie Lamport.</p>
<p><strong>Keith Marzullo, Alessandro Mei, and Hein Meling</strong> — A Simpler Proof for Paxos and Fast Paxos</p>
</blockquote>
<p>😂</p>
<span id="more"></span>
<h2 id="The-Problem-问题"><a class="header-anchor" href="#The-Problem-问题">¶</a>The Problem / 问题</h2>
<ul>
<li>
<p>Safety requirements for consensus / 一致性算法的基本要求:</p>
<ul>
<li><strong>1 / 约束 1: Only a value that has been proposed may be chosen / 只能通过已经被提出的值</strong></li>
<li><strong>2 / 约束 2: Only a single value is chosen / 只能通过单个值</strong></li>
<li><strong>3 / 约束 3: A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值</strong></li>
</ul>
</li>
<li>
<p>Roles / 角色</p>
<ul>
<li>
<p>Proposers / 议长，发起议案</p>
</li>
<li>
<p>Acceptors / 议员，赞成议案</p>
</li>
<li>
<p>Learners / 听众，了解议案</p>
</li>
</ul>
<blockquote>
<p>A single process may act as more than one agent / 允许身兼数职</p>
</blockquote>
</li>
<li>
<p>Asynchronous, non-Byzantine model / 异步，非拜占庭模型:</p>
<ul>
<li>Asynchronous / 异步: Agents operate at arbitrary speed, may fail by stopping, and may restart. Since all agents may fail after a value is chosen and then restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted. / 代理以任意速度运行，可能失效，也可能重启。由于可能出现在通过一个值以后全部代理都失效，所以代理失效前需要保存一些必要的信息，否则将无法恢复。</li>
<li>Non-Byzantine / 非拜占庭: Messages can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted. / 消息可能耗费任意长的时间送达，可能重复，也可能丢失，但是不会出错（保证发送的消息和接收到的消息一致）。</li>
</ul>
</li>
</ul>
<h2 id="Choosing-a-Value-值的通过"><a class="header-anchor" href="#Choosing-a-Value-值的通过">¶</a>Choosing a Value / 值的通过</h2>
<h3 id="Single-acceptor-agent-单个议员"><a class="header-anchor" href="#Single-acceptor-agent-单个议员">¶</a>Single acceptor agent / 单个议员</h3>
<p>A proposer sends a proposal to the acceptor, who chooses the first proposed value that it receives. / 议长向议员发送一份议案，议员通过最开始接收到的议案。</p>
<blockquote>
<p>Simple but unsatisfactory, because the failure of the acceptor makes any further progress impossible. / 简单但是还不够好，因为议员一旦失效，整个系统也随之失效。</p>
</blockquote>
<h3 id="Multiple-acceptor-agents-多个议员"><a class="header-anchor" href="#Multiple-acceptor-agents-多个议员">¶</a>Multiple acceptor agents / 多个议员</h3>
<p>A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is large enough? To ensure that only a single value is chosen, we can let a large enough set consist of any majority of the agents. Because any two majorities have at least one acceptor in common, this works if an acceptor can accept at most one value. / 一个议长将一份议案发送给一组议员。一个议员可能赞成该议案，也可能不赞成。当足够多的议员赞成了该议案，那么该议案就将通过。具体要多少议员赞成才是足够多？为了保证只有单个议案被通过，我们必须保证这一组议员包含全体议员中的多数议员 *，因为任何两组多数议员至少会包含一位共有议员，如果一位议员只能赞成一个提案的话，那么就能保证只有单个议案被通过。</p>
<blockquote>
<p>*Majority / * 多数: Majority means that a set is consisted of more than half of all acceptors / 多数表示这一组议员由全体议员的<strong>一半以上</strong>的议员组成。</p>
</blockquote>
<p>In the absence of failure or message loss, we want a value to be chosen even if only one value is proposed by a single proposer. / 在没有失效和信息丢失的情况下，如果只有一位议长，并且只提了一份议案，那么这个议案就应该被通过（否则系统将不能正常运行下去）。</p>
<ul>
<li><strong>P1 / 约束 P1: An acceptor must accept the first proposal that it receives. / 一位议员必须赞成其收到的第一份议案。</strong></li>
</ul>
<p>But this requirement raises a problem. Several values could be proposed by different proposers at about the same time, leading to a situation in which every acceptor has accepted a value, but no single value is accepted by a majority of them. Even with just two proposed values, if each is accepted by about half the acceptors, failure of a single acceptor could make it impossible to learn which of the values was chosen. / 但是约束 P1 还不够完备。不同的议长可能会同时发起多个不同的议案，可能导致不同的议员赞成了不同的议案，但是没有议案获得了多数议员的赞成。<strong>假设有两个议案，每个都获得了大约半数议员的赞同，如果议员总数为偶数个，系统将直接陷入死锁；如果议员总数为奇数个，那么最终决定权就落在了单个议员的手里，如果这时候该议员失效，那么系统就将陷入死锁。</strong></p>
<blockquote>
<p>上面的翻译我综合了自己的理解，可能和原文有些对应不上。</p>
</blockquote>
<p>P1 and the requirement that a value is chosen only when it is accepted by a majority of acceptors imply that an acceptor must be allowed to accept more than one proposal. / 约束 P1 和约束<em>当一份议案被多数议员赞成后才会被通过</em>隐含了条件<em>一位议员必须可以赞成不止一份议案</em>。（反证法）</p>
<p>We keep track of the different proposals that an acceptor may accept by assigning a (natural) number to each proposal, so a proposal consists of a proposal number and a value. To prevent confusion, we require that different proposals have different numbers. / 现在我们给议案分配一个自然数，所以现在一份议案是一个二元组（议案序号，值）。同时，为了唯一确定每一份议案，我们规定每一份议案的序号确定且唯一，并且议案的序号必须满足全序关系（全序关系即集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.928ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 852 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></svg></mjx-container>上的反对称（若 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container> 则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2291.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>）的、传递（若 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="4.967ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2195.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container> 则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.194ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 2295.6 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container>）的和完全（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 或 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>）的二元关系，简而言之，集合内的任意两个元素可以比较大小，计算机中的整型就满足全序关系，而 IEEE 754 定义的浮点数中，由于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex;" xmlns="http://www.w3.org/2000/svg" width="13.447ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 5943.6 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(888,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1417,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2582.8,0)"><path data-c="2270" d="M82 -124Q82 -120 83 -117T89 -110T95 -103H220L284 50Q346 204 344 206L218 268Q153 297 123 313T87 333T82 344T86 355Q104 369 291 455Q491 552 491 553L542 673Q581 767 590 784T609 801Q616 801 622 795T629 781Q629 773 586 677Q546 581 546 577L609 606Q669 635 673 635Q680 635 686 629T693 615Q693 610 692 608T670 593T604 561L524 521L400 226L542 157Q617 123 649 107T687 85T694 72Q694 66 690 60T679 54Q664 54 526 121Q513 127 495 136T464 150T438 162T416 173T399 180T388 185L384 186Q383 186 322 41L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124ZM418 370L466 495Q464 495 308 420T151 344T204 317T311 267T364 244Q364 247 418 370Z"></path></g><g data-mml-node="mi" transform="translate(3638.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(4526.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5055.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container>，所以 IEEE 754 不满足全序关系）。</p>
<p>A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. In that case, we say that the proposal (as well as its value) has been chosen. / 当一份包含值 v 的议案被多数议员赞成的时候，我们就说该议案（也包括值 v） 被通过了。</p>
<p>We can allow multiple proposals to be chosen, but we must guarantee that all chosen proposals have the same value. / 现在我们可以通过多个议案了，但是我们必须确保通过的多个议案都包含相同的值，这样才能保证约束 2。</p>
<ul>
<li>P2 / 约束 P2: If a proposal with value v is chosen, then <strong>every higher-numbered</strong> proposal that is chosen has value v. / 如果一份包含值 v 的议案已被通过，那么<strong>每一份大序号更大的</strong>议案都应该包含值 v。</li>
</ul>
<p>Since numbers are totally ordered, condition P2 guarantees the crucial safety property that only a single value is chosen. / 由于议案序号满足全序关系，所以约束 P2 能保证约束 2。</p>
<p>To be chosen, a proposal must be accepted by at least one acceptor. / 一份议案要被通过，那么这份议案至少要被一位议员赞成。</p>
<p>So, we can satisfy P2 by satisfying / 所以，我们可以对约束 P2 进行加强：</p>
<ul>
<li>P2a / 约束 P2a: If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被任何议员赞成的序号更大的议案也包含值 v。</li>
</ul>
<p>We still maintain P1 to ensure that some proposal is chosen. / 此时，我们仍然需要保证约束 P1，以确保有议案被通过。</p>
<p>Because communication is asynchronous, a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer “wakes up” and issues a higher-numbered proposal with a different value. P1 requires c to accept this proposal, violating P2a. / 但是由于通讯是异步的，可能出现某些特定的议员，比如议员 c 完全没有参与某个议案的情况。然后，议长又发起了一份更大序号的并且包含不同的值的议案，这时，根据约束 P1 议员 c 应该赞成该议案，但是这种情况却违反了约束 P2a。</p>
<p>Maintaining both P1 and P2a requires strengthening P2a to / 所以我们在约束 P2a 的基础上继续增强约束:</p>
<ul>
<li>P2b / 约束 P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被议长发起的序号更大的议案都包含值 v。</li>
</ul>
<p>Since a proposal must be issued by a proposer before it can be accepted by an acceptor, P2b implies P2a, which in turn implies P2. / 由于一份议案在被议员赞成之前必须现有议案则发起，所以约束 P2b 蕴含约束 P2a，又因为约束 P2a 蕴含约束 P2，故约束 P2b 也蕴含约束 P2。</p>
<p>To discover how to satisfy P2b, let’s consider how we would prove that it holds. / 约束 P2b 虽然约束足够强，但是难以提出实现方式，所以我们通过证明约束 P2b 成立的方式来进一步加强约束。</p>
<p>We would assume that some proposal with number m and value v is chosen and show that any proposal issued with number n &gt; m also has value v. / 假设一份序号为 m 值为 v 的议案 (m, v) 已经被通过，试证任何已发起的序号为 n 且 n &gt; m 的议案都包含值 v。</p>
<p>We would make the proof easier by using induction on n, so we can prove that proposal number n has value v under the additional assumption that every proposal issued with a number in m . . (n − 1) has value v , where i . . j denotes the set of numbers from i through j . / 为了简化证明过程，我们对 n 使用数学归纳法，这样我们就可以通过附加假设条件每一份以及发起的序号在 m 到 n-1 这个闭区间的议案都包含值 v 来证明序号为 n 的议案包含值 v。</p>
<p>For the proposal numbered m to be chosen, there must be some set C consisting of a majority of acceptors such that every acceptor in C accepted it. / 对于将要被通过的序号为 m 的议案，一定存在一个集合 C 由多数议员构成，并且集合 C 中的所有议员都赞成了该议案。</p>
<p>Combining this with the induction assumption, the hypothesis that m is chosen implies / 再结合刚才的归纳假设，假设 m 已被通过则意味着:</p>
<center>
    Every acceptor in C has accepted a proposal with number in m ..(n − 1), and every proposal with number in m ..(n − 1) accepted by any acceptor has value v. / 集合 C 中的每一位议员都接受了序号在 m 到 n-1 这个闭区间中的某个提议，并且每个序号在 m 到 n-1 这个闭区间中的提议都被包含值 v 的任意一位议员接受了。
</center>
<p>Since any set S consisting of a majority of acceptors contains at least one member of C, we can conclude that a proposal numbered n has value v by ensuring that the following invariant is maintained / 回顾前面对于‘多数’议员的定义，由于任意由多数议员组成的集合 S 和集合 C 之间至少有一位共同议员，那么我们通过保证以下的不变性来得出序号为 n 的议案包含值 v 的结论:</p>
<ul>
<li>P2c / 约束 P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。</li>
</ul>
<blockquote>
<p>结合 P2c 的假设和条件 (b) 可以证明 P2c 蕴含了 P2b</p>
</blockquote>
<p>To maintain the invariance of P2c, a proposer that wants to issue a proposal numbered n must learn the highest-numbered proposal with number less than n, if any, that has been or will be accepted by each acceptor in some majority of acceptors. / 为了维持约束 P2c 的不变性，当一位议长想发起一份值为 n 的议案之前，如果存在序号小于 n 的的议案的话，他必须先知道其中已经或者将要被多数议员赞成的序号最大的那一份议案。</p>
<p>Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances. In other words, the proposer requests that the acceptors not accept any more proposals numbered less than n. / 相对于预测将来的议员赞成情况而言，了解已经被议员赞成的议案要简单得多。因此，与其花大力气去预测未来，还不如通过承诺的方式来让议长控制不会有不符合条件的议案赞成情况。换句话说，议长要求议员作出承诺，保证不会再赞成序号小于 n 的议案。</p>
<p>This leads to the following algorithm for issuing proposals. / 这样，我们就得到了发起议案的算法:</p>
<ol>
<li>
<p>A proposer chooses a new proposal number n and sends a request to each member of some set of acceptors, asking it to respond with / 一位议长通过一个新的议案序号 n，然后向某个集合（应该是‘多数’议员）的全部议员发起请求，并要求对方回复以下两方面的内容:</p>
<p>(a) A promise never again to accept a proposal numbered less than n, and / 要求对方作出承诺，保证不再赞成任何序号小于 n 的议案</p>
<p>(b) The proposal with the highest number less than n that it has accepted, if any. / 已经赞成的序号小于 n 的议案中，序号最大的那一份议案</p>
<p>I will call such a request a prepare request with number n.  / 我们将这个过程称作序号 n 的准备请求</p>
</li>
<li>
<p>If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals. / 如果议长收到了多数议员的回复，那么他才能够发起序号为 n 值为 v 的议案，其中 v 是收到的回复中的所有议案里序号最大的那一份议案的值，如果所有回复中都不包含议案，那么 v 则由议长自行指定。</p>
</li>
</ol>
<p>A proposer issues a proposal by sending, to some set of acceptors, a request that the proposal be accepted. (This need not be the same set of acceptors that responded to the initial requests.), Let’s call this an accept request. / 最后，议长将确定好的议案作为请求发送给一组议员（<strong>这里的这一组议员不能和初始阶段的一样</strong>），我们将这个过程称为赞成请求。</p>
<p>What about an acceptor? It can receive two kinds of requests from proposers: prepare requests and accept<br>
requests. An acceptor can ignore any request without compromising safety. / 对于议员而言，其可以接收两种来自议长的请求：准备请求和赞成请求。并且议员会忽略掉那些不满足约束的请求。</p>
<p>So, we need to say only when it is allowed to respond to a request. It can always respond to a prepare request. It can respond to an accept request, accepting the proposal, iff it has not promised not to. In other words / 所以，对于准备请求而言，议员总是可以响应；对于赞成请求而言，当且仅当该议员没有承诺过不赞成该请求时，才响应。换句话说 :</p>
<ul>
<li>P1a / 约束 P1a: An acceptor can accept a proposal numbered n iff it has not responded<br>
to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。</li>
</ul>
<p>Observe that P1a subsumes P1. / 通过观察可以发现约束 P1a 蕴含 P1。</p>
<p>We now have a complete algorithm for choosing a value that satisfies the required safety properties—assuming unique proposal numbers. The final algorithm is obtained by making one small optimization. / 至此，在议案序号唯一的前提下，我们通过推导得到了完整的通过值的算法。最终的算法还可以在此基础上做一些优化。</p>
<p>Suppose an acceptor receives a prepare request numbered n, but it has already responded to a prepare request numbered greater than n, thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request, since it will not accept the proposal numbered n that the proposer wants to issue. So we have the acceptor ignore such a prepare request. We also have it ignore a prepare request for a proposal it has already accepted. 在议员已经响应了一个序号大于 n 的准备请求以后，对于序号为 n 的准备请求就没有必要响应了。同时，对于已经赞成的议案，也没有必要再赞成第二次。</p>
<p>With this optimization, an acceptor needs to remember only the highest-numbered proposal that it has ever accepted and the number of the highest-numbered prepare request to which it has responded. Because P2c must be kept invariant regardless of failures, an acceptor must remember this<br>
information even if it fails and then restarts. / 经过上面的优化以后，议员只需要保存他赞成过的议案中序号最大的那一份和响应过得准备请求中序号最大的那一个就行。因为即使在有失效的情况下我们也必须维护约束 P2c 的不变性，议员就算经历失效或者重启也必须保存上面的信息。</p>
<p>Note that the proposer can always abandon a proposal and forget all about it—as long as it never tries to issue another proposal with the same number. / 值得注意的是，议长总是可以通过不再发起相同序号的新议案的方式来放弃并且遗忘调一份议案。</p>
<h3 id="Conclude-总结"><a class="header-anchor" href="#Conclude-总结">¶</a>Conclude / 总结</h3>
<p>Requirements for the algorithm / 算法的约束:</p>
<ul>
<li>1 / 约束 1: <strong>Only a value that has been proposed may be chosen / 只能通过已经被提出的值</strong></li>
<li>2 / 约束 2: <strong>Only a single value is chosen / 只能通过单个值</strong></li>
<li>3 / 约束 3: <strong>A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值</strong></li>
<li>P1a / 约束 P1a: <strong>An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。</strong></li>
<li>P2c / 约束 P2c: <strong>For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。</strong></li>
</ul>
<p>Properties of the algorithm / 算法的特性:</p>
<ul>
<li>
<p>Immutability of value / 值的不可变性</p>
<blockquote>
<p>要么集群中没有任何议案被提出，这时没有值，一旦有合法的议案被提出，无论后面有多少新的合法的议案被提出，值都是最开始的合法议案中的值。所以称值具有不可变性。</p>
</blockquote>
</li>
<li>
<p>Minority obeying majority / 少数服从多数</p>
<blockquote>
<p>多数定义是至少为全体的一半以上（不包括刚好一半）。</p>
</blockquote>
</li>
<li>
<p>Prevent the occurrence, Instead of trying to predict the future / 与其预测未来，不如提前预防</p>
<blockquote>
<p>要求议员在准备阶段作出承诺。</p>
</blockquote>
</li>
</ul>
<h3 id="The-Algorithm-算法"><a class="header-anchor" href="#The-Algorithm-算法">¶</a>The Algorithm / 算法</h3>
<p>Putting the actions of the proposer and acceptor together, we see that the algorithm operates in the following two phases. / 将上面的过程整合在一起，我们就得到了最终的算法（通过值部分）:</p>
<ul>
<li>
<p>Phase 1 / 阶段 1</p>
<ul>
<li>(a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors. / 一位议长通过一份议案序号 n，并向多数议员发送序号为 n 的准备请求。</li>
<li>(b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted. / 如果一位议员接收到的序号为 n 的准备请求的序号大于了任何已经响应的准备请求，那么该议员将响应接收到的序号为 n 的准备请求，作出承诺不再赞成任何序号小于 n 的，并且，如果已经赞成过任何议案的话，顺便返回其中序号最大的那一个（同发起议案算法第 1 点）。</li>
</ul>
</li>
<li>
<p>Phase 2 / 阶段 2</p>
<ul>
<li>(a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals. / 如果议长收到了多数议员对序号为 n 的准备请求的响应，那么议长就开始向另一组多数议员中的每一位发送序号为 n 值为 v 的议案，其中 v 是收到的响应中的议案中序号最大的那一份议案所包含的值，如果收到的响应中不包含任何议案，那么值 v 由议长任意指定。</li>
<li>(b) If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n. / 如果一位议员收到序号为 n 的赞成请求，在没有响应过序号大于 n 的准备请求的情况下，该议员将赞成此议案。</li>
</ul>
</li>
</ul>
<p>A proposer can make multiple proposals, so long as it follows the algorithm for each one. / 议长可以发起多个议案，前提是每一份议案都需要按照算法的流程进行。</p>
<p>It can abandon a proposal in the middle of the protocol at any time. (Correctness is maintained, even though requests and/or responses for the proposal may arrive at their destinations long after the proposal was abandoned.) / 议长可以在任何时候中途废弃议案。（尽管请求或者响应可能在到达目的地之前就已经被废弃，但正确性依然不会受到影响。）</p>
<p>It is probably a good idea to abandon a proposal if some proposer has begun trying to issue a higher-numbered one. / 在某个议长尝试发起一个序号更大的议案时，废弃已有的议案可能是个不错的想法。</p>
<p>Therefore, if an acceptor ignores a prepare or accept request because it has already received a prepare request with a higher number, then it should probably inform the proposer, who should then abandon its proposal. This is a performance optimization that does not affect correctness. / 因此，在一位议员因为已经接收到了更大序号的准备请求后，而忽略当前准备或者赞成请求的时候，该议员应该通知相应的议长废弃当前议案。这在不影响正确性的情况下提高了性能。</p>
<h2 id="Learning-a-Chosen-Value-了解已通过的值"><a class="header-anchor" href="#Learning-a-Chosen-Value-了解已通过的值">¶</a>Learning a Chosen Value / 了解已通过的值</h2>
<p>To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm is to have each acceptor, whenever it accepts a proposal, respond to all learners, sending them the proposal. This allows learners to find out about a chosen value as soon as possible, but it requires each acceptor to respond to each learner—a number of responses equal to the product of the number of acceptors and the number of learners. / 为了使听众了解已经被通过的值，听众必须得知道被多数议员赞成的议案的内容。最直观的算法就是，每当议员赞成某个提案时，就通知所有的听众，向他们发送该议案。这样可以保证及时性，但是复杂度太高，达到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.967ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3963.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(2696.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3574.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ，这里 n 是议员个数，m 是听众个数。</p>
<p>The assumption of non-Byzantine failures makes it easy for one learner to find out from another learner that a value has been accepted. We can have the acceptors respond with their acceptances to a distinguished learner, which in turn informs the other learners when a value has been chosen. This approach requires an extra round for all the learners to discover the chosen value. It is also less reliable, since the distinguished learner could fail. But it requires a number of responses equal only to the sum of the number of acceptors and the number of learners. / 回顾前面的非拜占庭假设，我们发现听众可以通过其他听众来准确的了解已被赞成的议案。这样一来，议员就只需要通知某个特定的听众了，剩下的通知工作就可以由听众之间的相互传递来完成。于是，复杂度降低到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.596ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4241.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3852.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 。但是，这样的话这位特定的听众就成了单点，会导致可靠性下降很多。</p>
<blockquote>
<p>复杂度好像还可以更低，如果听众之间用 P2P 通信，应该可以降到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.434ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5938 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3272.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(3757.4,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(4671,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5549,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
</blockquote>
<p>More generally, the acceptors could respond with their acceptances to some set of distinguished learners, each of which can then inform all the learners when a value has been chosen. Using a larger set of distinguished learners provides greater reliability at the cost of greater communication complexity. / 介于以上两种策略都有致命的缺陷，一种复杂度太高，另一种可靠性太低，于是我们取两者的折中方案。将第二种方法中的特定听众由一位扩展到一组。以此提高可靠性，但是会以复杂度的提升为代价，需要根据具体场景做权衡。</p>
<p>Because of message loss, a value could be chosen with no learner ever finding out. The learner could ask the acceptors what proposals they have accepted, but failure of an acceptor could make it impossible to know whether or not a majority had accepted a particular proposal. In that case, learners will find out what value is chosen only when a new proposal is chosen. If a learner needs to know whether a value has been chosen, it can have a proposer issue a proposal, using the algorithm described above. / 由于消息有可能会丢失，那么就可能出现一个值被通过了，却没有任何听众了解。听众可以主动询问议员已经赞成了什么议案，但是在极端情况（多数议员之间只有一个共同议员的情况）下，一位议员失效就将导致无法区分该议案是否获得了多数议员的赞成。在这种情况下，听众只能被动的在新的提案被通过的时候才能了解被多数议员赞成的值。如果听众需要主动获得当先被多数议员通过的值，那么他只能通过发起一次新的议案来达到目的，但这也要求该听众同时也是议长（身兼多职）。</p>
<h2 id="The-Progress-过程"><a class="header-anchor" href="#The-Progress-过程">¶</a>The Progress / 过程</h2>
<p>It’s easy to construct a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers, none of which are ever chosen. Proposer p completes phase 1 for a proposal number n1. Another proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer p’s phase 2 accept requests for a proposal numbered n1 are ignored because the acceptors have all promised not to accept any new proposal numbered less than n2. So, proposer p then begins and completes phase 1 for a new proposal number n3 &gt; n2, causing the second phase 2 accept requests of proposer q to be ignored. And so on. / 即使对于上面的算法，仍然可以轻易的构造出两位议长交替发起序号更大的议案，但却无法最终确定的情况，称之为活锁。例如：议长 p 完成了序号为 n1 的阶段 1。另一位议长 q 然后完成了序号 n2 的阶段 1，并且 n2 &gt; n1。议长 p 的阶段 2 的赞成请求会由于议员响应了 议长 q 的 n2 的准备请求（保证不再赞成任何序号小于 n2 的议案）而被忽略。这样，议长 p 就会发起序号为 n3 的阶段 1，且 n3 &gt; n2，于是议长 q 的 序号为 n2 的议案的阶段 2 又会由于议员响应了 议长 p 的 n3 的准备请求（保证不再赞成任何序号小于 n3 的议案）而被忽略，以此循环往复，无休无止。</p>
<p>To guarantee progress, a distinguished proposer must be selected as the only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors, and if it uses a proposal with number greater than any already used, then it will succeed in issuing a proposal that is accepted. By abandoning a proposal and trying again if it learns about some request with a higher proposal number, the distinguished proposer will eventually choose a high enough proposal number.  / 为了保证流程的正常进行，避免活锁的情况，系统中必须只能有一位议长，并且作为唯一的议案发起者，当该议长能够正常的和多数议员通信并且使用大于任何已有议案的序号的议案序号，那么就能保证发起的议案被正常赞成。当该议长了解更大的序号时，废弃当前议案，并发起一份序号更大的议案，以此往复，最终就能发起一份序号足够大的议案，并获得赞成。</p>
<blockquote>
<p>这样一来，这位集群中唯一的议长就成了单点，为了解决这个问题，需要一种选举算法，在这位议长失效或重启时，及时的选举出替代者，以保证集群正常运作。</p>
</blockquote>
<blockquote>
<p>值得注意的是，为了避免活锁，算法现在只允许集群中有一位议长，而不是最开始的多位议长了，并且增加了议长选举机制（可能是从议员或者听众之间选举，也可能是其他角色）。</p>
</blockquote>
<p>If enough of the system (proposer, acceptors, and communication network) is working properly, liveness can therefore be achieved by electing a single distinguished proposer. / 如果有足够多的系统（单个议长，多位议员，以及通信网络）正常运行，集群的健康度就能通过议长的选举来保证。</p>
<h2 id="Extension-拓展"><a class="header-anchor" href="#Extension-拓展">¶</a>Extension / 拓展</h2>
<ul>
<li>
<p>The Part-Time Parliament</p>
<p>Paxos 算法的最初论文。</p>
<blockquote>
<p>论文：The Part-Time Parliament, by Leslie Lamport</p>
</blockquote>
</li>
<li>
<p>Multi-Paxos</p>
<p>Paxos 是对一个值达成一致，Multi-Paxos 是运行多个 Paxos 实例来对多个值达成一致，每个 Paxos 实例对不同的值达成一致。</p>
<blockquote>
<p>论文：Multi-Paxos: An Implementation and Evaluation, by Hao Du and David J. St. Hilaire</p>
</blockquote>
</li>
<li>
<p>Fast-Paxos</p>
<p>Paxos 的进一步工程化，就是 Client 的提案由 Coordinator 进行，Coordinator 存在多个，但只能通过其中被选定 Leader 进行；提案由 Leader 交由 Server (Acceptor) 进行表决，之后 Client 作为 Learner 学习决议的结果。这种方式更多地考虑了 Client / Server 这种通用架构，更清楚地注意到了 Client 既作为 Proposer 又作为 Learner 这一事实。</p>
<blockquote>
<p>论文：Fast Paxos, by Leslie Lamport</p>
<p>论文：A Simpler Proof for Paxos and Fast Paxos, by by Keith Marzullo, Alessandro Mei and Hein Meling</p>
</blockquote>
</li>
<li>
<p>Raft</p>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance. The difference is that it’s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. / Raft 算法被设计的更容易理解。在容错和性能方面与 Paxos 算法相当。</p>
<blockquote>
<p>论文及实现：<a href="https://raft.github.io/">Raft Consensus Algorithm</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/zh/about/index.html</url>
    <content><![CDATA[<center>热爱计算机</center>
<center>热爱互联网</center>
<center>热爱人工智能</center>
<br>
<center>极客</center>
<center>极简主义者</center>
<center>兴趣和好奇心驱动</center>
<br>
<center>不变初心，特立独行。</center>
]]></content>
  </entry>
  <entry>
    <title>书籍</title>
    <url>/zh/books/index.html</url>
    <content><![CDATA[<h2 id="程序设计语言"><a class="header-anchor" href="#程序设计语言">¶</a> 程序设计语言</h2>
<h3 id="基础"><a class="header-anchor" href="#基础">¶</a> 基础</h3>
<ul>
<li>
<p>《C 程序设计语言》（The C Programming Language）</p>
<p>作者：Brian Kernighan，Dennis Ritchie</p>
</li>
<li>
<p>《C++ Primer》</p>
<p>作者：Stanley B. Lippman，Josée Lajoie，Barbara E. Moo</p>
</li>
<li>
<p>《Java 编程思想》（Thinking in Java）</p>
<p>作者：Bruce Eckel</p>
</li>
</ul>
<h3 id="进阶"><a class="header-anchor" href="#进阶">¶</a> 进阶</h3>
<ul>
<li>
<p>《Java 并发编程实战》（Java Concurrency in Practice）</p>
<p>作者：Brian Goetz，Tim Peierls，Joshua Bloch，Joseph Bowbeer，David Holmes，Doug Lea</p>
</li>
<li>
<p>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》</p>
<p>作者：周志明</p>
</li>
</ul>
<h2 id="算法与数据结构"><a class="header-anchor" href="#算法与数据结构">¶</a> 算法与数据结构</h2>
<h3 id="基础-2"><a class="header-anchor" href="#基础-2">¶</a> 基础</h3>
<ul>
<li>
<p>《算法》（Algorithms）</p>
<p>作者：Robert Sedgewick，Kevin Wayne</p>
</li>
<li>
<p>《算法导论》（Introduction to Algorithms）</p>
<p>作者：Thomas H. Cormen，Charles E. Leiserson，Ronald L. Rivest，Clifford Stein</p>
</li>
</ul>
<h3 id="进阶-2"><a class="header-anchor" href="#进阶-2">¶</a> 进阶</h3>
<ul>
<li>
<p>《算法分析导论》（An Introduction to the Analysis of Algorithms）</p>
<p>作者：Robert Sedgewick, Philippe Flajolet</p>
</li>
</ul>
<h2 id="数据库"><a class="header-anchor" href="#数据库">¶</a> 数据库</h2>
<h3 id="基础-3"><a class="header-anchor" href="#基础-3">¶</a> 基础</h3>
<ul>
<li>
<p>《数据库系统：全书》（Database Systems: The Complete Book）</p>
<p>作者：Hector Garcia-Molina，Jeff Ullman，Jennifer Widom</p>
</li>
</ul>
<h3 id="进阶-3"><a class="header-anchor" href="#进阶-3">¶</a> 进阶</h3>
<ul>
<li>
<p>《高性能 MySQL》（High Performance MySQL: Optimization, Backups, and Replication）</p>
<p>作者：Baron Schwartz，Peter Zaitsev，Vadim Tkachenko</p>
</li>
<li>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
<p>作者：姜承尧</p>
</li>
<li>
<p>《Redis 设计与实现》</p>
<p>作者：黄健宏</p>
</li>
</ul>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a> 计算机网络</h2>
<h3 id="基础-4"><a class="header-anchor" href="#基础-4">¶</a> 基础</h3>
<ul>
<li>
<p>《计算机网络：自顶向下方法》（Computer Networking: A Top-Down Approach）</p>
<p>作者：James F. Kurose，Keith W. Ross</p>
</li>
</ul>
<h3 id="进阶-4"><a class="header-anchor" href="#进阶-4">¶</a> 进阶</h3>
<ul>
<li>
<p>《TCP/IP 详解 卷 1：协议》（TCP/IP Illustrated, Volume 1: The Protocols）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《TCP/IP 详解 卷 2：实现》（TCP/IP Illustrated, Volume 2: The Implementation）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议》（TCP/IP Illustrated, Vol. 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《UNIX 网络编程 卷 1：套接字联网 API》（Unix Network Programming, Volume 1: The Sockets Networking API）</p>
<p>作者：W. Richard Stevens，Bill Fenner，Andrew M. Rudof</p>
</li>
<li>
<p>《UNIX 网络编程 卷 2：进程间通信》（UNIX Network Programming, Volume 2: Interprocess Communications）</p>
<p>作者：W. Richard Stevens</p>
</li>
</ul>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a> 操作系统</h2>
<h3 id="基础-5"><a class="header-anchor" href="#基础-5">¶</a> 基础</h3>
<ul>
<li>
<p>《现代操作系统》（Modern Operating Systems）</p>
<p>作者：Andrew S. Tanenbaum</p>
</li>
</ul>
<h3 id="进阶-5"><a class="header-anchor" href="#进阶-5">¶</a> 进阶</h3>
<ul>
<li>
<p>《UNIX 环境高级编程》（Advanced Programming in the UNIX Environment）</p>
<p>作者：W. Richard Stevens，Stephen A. Rago</p>
</li>
</ul>
<h2 id="计算机体系结构"><a class="header-anchor" href="#计算机体系结构">¶</a> 计算机体系结构</h2>
<h3 id="基础-6"><a class="header-anchor" href="#基础-6">¶</a> 基础</h3>
<ul>
<li>
<p>《计算机体系结构：量化研究方法》（Computer Architecture: A Quantitative Approach）</p>
<p>作者：John L. Hennessy，David A. Patterson</p>
</li>
<li>
<p>《计算机组成与设计：硬件、软件接口》（Computer Organization and Design: The Hardware / Software Interface）</p>
<p>作者：David A. Patterson，John L. Hennessy</p>
</li>
</ul>
<h2 id="编译原理"><a class="header-anchor" href="#编译原理">¶</a> 编译原理</h2>
<h3 id="基础-7"><a class="header-anchor" href="#基础-7">¶</a> 基础</h3>
<ul>
<li>
<p>《编译原理》（Compilers: Principles, Techniques, and Tools）</p>
<p>作者：Alfred V. Aho，Monica S. Lam，Ravi Sethi，Jeffrey D. Ullman</p>
</li>
</ul>
<h2 id="计算机科学"><a class="header-anchor" href="#计算机科学">¶</a> 计算机科学</h2>
<h3 id="基础-8"><a class="header-anchor" href="#基础-8">¶</a> 基础</h3>
<ul>
<li>
<p>《深入理解计算机系统》（Computer Systems: A Programmer’s Perspective）</p>
<p>作者：Randal E. Bryant，David R. O’Hallaron</p>
</li>
</ul>
<h2 id="机器学习"><a class="header-anchor" href="#机器学习">¶</a> 机器学习</h2>
<h3 id="基础-9"><a class="header-anchor" href="#基础-9">¶</a> 基础</h3>
<ul>
<li>
<p>《机器学习》</p>
<p>作者：周志华</p>
</li>
<li>
<p>《统计学习方法》</p>
<p>作者：李航</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/zh/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>论文</title>
    <url>/zh/papers/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/zh/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>课程</title>
    <url>/zh/courses/index.html</url>
    <content><![CDATA[<h2 id="算法与数据结构"><a class="header-anchor" href="#算法与数据结构">¶</a> 算法与数据结构</h2>
<h3 id="基础"><a class="header-anchor" href="#基础">¶</a> 基础</h3>
<ul>
<li>
<p>Algorithms, <a href="https://www.coursera.org/learn/algorithms-part1">Part I</a>, <a href="https://www.coursera.org/learn/algorithms-part2">Part II</a></p>
<p>导师：Robert Sedgewick、Kevin Wayne</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/">6.006: Introduction to Algorithms</a></p>
<p>导师：Erik Demaine，Srinivas Devadas</p>
<p>机构：MIT</p>
<p>平台：MIT OpenCourseWare</p>
</li>
</ul>
<h3 id="进阶"><a class="header-anchor" href="#进阶">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/analysis-of-algorithms">Analysis of Algorithms</a></p>
<p>导师：Robert Sedgewick</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/">6.046J: Design and Analysis of Algorithms</a></p>
<p>导师：Erik Demaine、Srinivas Devadas、Nancy Lynch</p>
<p>机构：MIT</p>
<p>平台：MIT OpenCourseWare</p>
</li>
</ul>
<h2 id="数据库"><a class="header-anchor" href="#数据库">¶</a> 数据库</h2>
<h3 id="基础-2"><a class="header-anchor" href="#基础-2">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Home/Databases/Engineering/about">Databases Mini-courses, Introduction to Databases</a></p>
<p>导师：Jennifer Widom</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a> 计算机网络</h2>
<h3 id="基础-3"><a class="header-anchor" href="#基础-3">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about">Introduction to Computer Networking</a></p>
<p>导师：Philip Levis、Nick McKeown</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a> 操作系统</h2>
<h3 id="进阶-2"><a class="header-anchor" href="#进阶-2">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/">6.828: Operating System Engineering</a></p>
<p>导师：Adam Belay、Frans Kaashoek</p>
<p>机构：MIT</p>
<p>平台：MIT</p>
</li>
</ul>
<h2 id="计算机体系结构"><a class="header-anchor" href="#计算机体系结构">¶</a> 计算机体系结构</h2>
<h3 id="基础-4"><a class="header-anchor" href="#基础-4">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/comparch">Computer Architecture</a></p>
<p>导师：David Wentzlaff</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="编译原理"><a class="header-anchor" href="#编译原理">¶</a> 编译原理</h2>
<h3 id="基础-5"><a class="header-anchor" href="#基础-5">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about">Compilers</a></p>
<p>导师：Alex Aiken</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="数学"><a class="header-anchor" href="#数学">¶</a> 数学</h2>
<h3 id="基础-6"><a class="header-anchor" href="#基础-6">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/mathematical-thinking">Introduction to Mathematical Thinking</a></p>
<p>导师：Keith Devlin</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://www.coursera.org/learn/logic-introduction">Introduction to Logic</a></p>
<p>导师：Michael Genesereth</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h3 id="进阶-3"><a class="header-anchor" href="#进阶-3">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/CVX101/Winter2014/about">Convex Optimization</a></p>
<p>导师：Stephen Boyd、Henryk Blasinski、Neal Parikh、Ernest Ryu、Madeleine Udell</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="分布式系统"><a class="header-anchor" href="#分布式系统">¶</a> 分布式系统</h2>
<h3 id="进阶-4"><a class="header-anchor" href="#进阶-4">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://pdos.csail.mit.edu/6.824/">6.824: Distributed Systems</a></p>
<p>导师：Robert Morris、Malte Schwarzkopf</p>
<p>机构：MIT</p>
<p>平台：MIT</p>
</li>
</ul>
<h2 id="机器学习"><a class="header-anchor" href="#机器学习">¶</a> 机器学习</h2>
<h3 id="基础-7"><a class="header-anchor" href="#基础-7">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a></p>
<p>导师：Andrew Ng</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://www.coursera.org/specializations/deep-learning">Deep Learning Specialization</a></p>
<p>导师：Andrew Ng</p>
<p>机构：<a href="http://deeplearning.ai">deeplearning.ai</a></p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://lagunita.stanford.edu/courses/HumanitiesSciences/StatLearning/Winter2016/about">Statistical Learning</a></p>
<p>导师：Trevor Hastie、Rob Tibshirani</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h3 id="进阶-5"><a class="header-anchor" href="#进阶-5">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="http://cs231n.stanford.edu/2017/">CS231n: Convolutional Neural Networks for Visual Recognition</a>, <a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv">课程视频</a></p>
<p>导师：Fei-Fei Li、Justin Johnson、Serena Yeung</p>
<p>机构：Stanford University</p>
<p>平台：Stanford University</p>
</li>
<li>
<p><a href="https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1162/">CS224n: Natural Language Processing</a>, <a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6">课程视频</a></p>
<p>导师：Chris Manning</p>
<p>机构：Stanford University</p>
<p>平台：Stanford University</p>
</li>
<li>
<p><a href="http://rail.eecs.berkeley.edu/deeprlcourse/">CS 294-112 Deep Reinforcement Learning</a></p>
<p>导师：Sergey Levine</p>
<p>机构：UC Berkeley</p>
<p>平台：UC Berkeley</p>
</li>
</ul>
<h2 id="密码学"><a class="header-anchor" href="#密码学">¶</a> 密码学</h2>
<h3 id="基础-8"><a class="header-anchor" href="#基础-8">¶</a> 基础</h3>
<ul>
<li>
<p>Cryptography, <a href="https://www.coursera.org/learn/crypto">I</a>, <a href="https://www.coursera.org/learn/crypto2">II</a></p>
<p>导师：Dan Boneh</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="博弈论"><a class="header-anchor" href="#博弈论">¶</a> 博弈论</h2>
<h3 id="基础-9"><a class="header-anchor" href="#基础-9">¶</a> 基础</h3>
<ul>
<li>
<p>Game Theory, <a href="https://www.coursera.org/learn/game-theory-1">I</a>, <a href="https://www.coursera.org/learn/game-theory-2">II</a></p>
<p>导师：Matthew O. Jackson、Kevin Leyton-Brown、Yoav Shoham</p>
<p>机构：Stanford University、The University of British Columbia</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="程序设计语言"><a class="header-anchor" href="#程序设计语言">¶</a> 程序设计语言</h2>
<h3 id="基础-10"><a class="header-anchor" href="#基础-10">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/unix">The Unix Workbench</a></p>
<p>导师：Sean Kross、Jeff Leek、Brian Caffo、Roger D. Peng</p>
<p>机构：Johns Hopkins University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h3 id="进阶-6"><a class="header-anchor" href="#进阶-6">¶</a> 进阶</h3>
<ul>
<li>
<p>Programming Languages, <a href="https://www.coursera.org/learn/programming-languages">A</a>, <a href="https://www.coursera.org/learn/programming-languages-part-b">B</a>, <a href="https://www.coursera.org/learn/programming-languages-part-c">C</a></p>
<p>导师：Dan Grossman</p>
<p>机构：University of Washington</p>
<p>平台：Coursera</p>
</li>
</ul>
]]></content>
  </entry>
</search>
